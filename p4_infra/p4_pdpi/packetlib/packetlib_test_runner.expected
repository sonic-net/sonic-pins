================================================================================
Parsing test: Ethernet packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x002e  # This means size(payload) = 0x2e bytes = 46 bytes.
    # payload
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x002e"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377\000\021\"3DUfw\210\231\252\273\314\335\356\377\000\021\"3DUfw\210\231\252\273\314\335"

================================================================================
Parsing test: Ethernet packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0001  # This means size(payload) = 1 byte.
    # payload
    payload: 0x0102  # 2 bytes, but ether_type says 1 byte & minimum size is 46.
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0001"
  }
}
payload: "\001\002"
reasons_invalid: "in EthernetHeader headers[0]: ethertype: value 0x0001 is <= 1500 and should thus match payload size, but payload size is 2 bytes"

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: Ethernet packet (unsupported EtherType)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0842  # Wake-on-LAN
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0842"
  }
}
reason_not_fully_parsed: "ethernet_header.ethertype 0x0842: unsupported"
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 0"

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = false
ValidatePacket(packet) = OK
================================================================================
Parsing test: IPv4 packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x6fc6
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0x1234
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    # other headers:
    payload: 0x1234
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x6fc6"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0x1234"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "\0224"
reason_not_fully_parsed: "ipv4_header.protocol 0x05: unsupported"
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 22"
reasons_invalid: "in Ipv4Header headers[1]: total_length: Must be 0x0016, but was 0x6fc6 instead."
reasons_invalid: "in Ipv4Header headers[1]: checksum: Must be 0x78f5, but was 0x1234 instead."

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: IPv4 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0034
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0xe887
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    # payload:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377\000\021\"3DUfw\210\231\252\273\314\335\356\377"
reason_not_fully_parsed: "ipv4_header.protocol 0x05: unsupported"

================================================================================
Parsing test: IPv4 packet (checksum example)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # wikipedia.org/wiki/IPv4_header_checksum#Calculating_the_IPv4_header_checksum
    #
    # ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header and payload
    ipv4_header: 0x 4500 0073 0000 4000 4011 b861 c0a8 0001 c0a8 00c7
    payload: 0x 0035 e97c 005f 279f 1e4b 8180
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x0073"
    identification: "0x0000"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0x40"
    protocol: "0x11"
    checksum: "0xb861"
    ipv4_source: "192.168.0.1"
    ipv4_destination: "192.168.0.199"
  }
}
headers {
  udp_header {
    source_port: "0x0035"
    destination_port: "0xe97c"
    length: "0x005f"
    checksum: "0x279f"
  }
}
payload: "\036K\201\200"
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 32"
reasons_invalid: "in Ipv4Header headers[1]: total_length: Must be 0x0020, but was 0x0073 instead."
reasons_invalid: "in UdpHeader headers[2]: length: Must be 0x000c, but was 0x005f instead."
reasons_invalid: "in UdpHeader headers[2]: checksum: Must be 0xf399, but was 0x279f instead."

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: IPv4 packet with options (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x6  # 5 + 1 x 32-bit suffix
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0038
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0xa31d
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    uninterpreted_suffix: 0x11223344
    # Payload
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0038"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xa31d"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
    uninterpreted_options: "0x11223344"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377\000\021\"3DUfw\210\231\252\273\314\335\356\377"
reason_not_fully_parsed: "ipv4_header.protocol 0x05: unsupported"

================================================================================
Parsing test: IPv4 packet with options (too short)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x6  # 5 + 1 x 32-bit suffix
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0018
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x05  # some unsupported protocol
    checksum: 0xd6a3
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    uninterpreted_suffix: 0x11  # Should be 32 bits, but is only 8 bits.
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0018"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xd6a3"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
    uninterpreted_options: "0x11"
  }
}
reason_not_fully_parsed: "ipv4_header.protocol 0x05: unsupported"
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 21"
reasons_invalid: "in Ipv4Header headers[1]: uninterpreted_options: found 8 bits, but expected multiple of 32 bits"
reasons_invalid: "in Ipv4Header headers[1]: ihl: Correct value undefined since uninterpreted_options is invalid."
reasons_invalid: "in Ipv4Header headers[1]: total_length: Must be 0x0015, but was 0x0018 instead."

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = INVALID_ARGUMENT: Ipv4Header: failed to compute packet.headers[1].ihl: uninterpreted_options field is invalid
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: uninterpreted_options: found 8 bits, but expected multiple of 32 bits
- in Ipv4Header headers[1]: ihl: Correct value undefined since uninterpreted_options is invalid.
- in Ipv4Header headers[1]: total_length: Must be 0x002e, but was 0x0018 instead.
================================================================================
Parsing test: IPv4 packet with IP protocol 0xfd
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header:
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x0034
    identification: 0xa3cd
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0xfd  # Reserved for experimentation -- payload is arbitrary.
    checksum: 0xe78f
    ipv4_source: 0x0a000001
    ipv4_destination: 0x14000003
    # payload:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0xfd"
    checksum: "0xe78f"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377\000\021\"3DUfw\210\231\252\273\314\335\356\377"

================================================================================
Parsing test: IPv6 packet with IP protocol 0xfe
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xffeeddccbbaa
    ethernet_source: 0x554433221100
    ether_type: 0x86DD
    # IPv6 header:
    version: 0x6
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0010
    next_header: 0xfd  # Reserved for experimentation -- payload is arbitrary.
    hop_limit: 0x03
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0010"
    next_header: "0xfd"
    hop_limit: "0x03"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377"

================================================================================
Parsing test: IPv6 packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xffeeddccbbaa
    ethernet_source: 0x554433221100
    ether_type: 0x86DD
    # IPv6 header:
    version: 0x4
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0000
    next_header: 0x90  # some unassigned protocol
    hop_limit: 0xff
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x12
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x4"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x90"
    hop_limit: "0xff"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "\022"
reason_not_fully_parsed: "ipv6_header.next_header 0x90: unsupported"
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 41"
reasons_invalid: "in Ipv6Header headers[1]: version: Must be 0x6, but was 0x4 instead."
reasons_invalid: "in Ipv6Header headers[1]: payload_length: Must be 0x0001, but was 0x0000 instead."

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: IPv6 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xffeeddccbbaa
    ethernet_source: 0x554433221100
    ether_type: 0x86DD
    # IPv6 header:
    version: 0x6
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0020
    next_header: 0x90  # some unassigned protocol
    hop_limit: 0x03
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0020"
    next_header: "0x90"
    hop_limit: "0x03"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377\000\021\"3DUfw\210\231\252\273\314\335\356\377"
reason_not_fully_parsed: "ipv6_header.next_header 0x90: unsupported"

================================================================================
Parsing test: UDP packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.securitynik.com/2015/08/calculating-udp-checksum-with-taste-of.html
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x0800
    # IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b011011
    ecn: 0b01
    total_length: 0x002e
    identification: 0x0000
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x10
    protocol: 0x11  # UDP
    checksum: 0x28c5
    ipv4_source: 0xc0a8001f       # 192.168.0.31
    ipv4_destination: 0xc0a8001e  # 192.168.0.30
    # UDP header
    source_port: 0x0014       # 20
    destination_port: 0x000a  # 10
    length: 0x001a            # 26
    checksum: 0x7961
    # Payload
    payload: 0x4869                                             # "Hi" in ASCII
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff  # Padding
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x002e"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x11"
    checksum: "0x28c5"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x001a"
    checksum: "0x7961"
  }
}
payload: "Hi\000\021\"3DUfw\210\231\252\273\314\335\356\377"

================================================================================
Parsing test: TCP packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.erg.abdn.ac.uk/users/gorry/course/inet-pages/packet-decode3.html
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x 00 e0 f7 26 3f e9
    ethernet_source: 0x 08 00 20 86 35 4b
    ether_type: 0x0800
    # IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b000000
    ecn: 0b00
    total_length: 0x002e
    identification: 0x08b8
    flags: 0b010
    fragment_offset: 0b0000000000000
    ttl: 0xff
    protocol: 0x06  # TCP
    checksum: 0x9995
    ipv4_source: 0x8b85d96e       # 139.133.217.110
    ipv4_destination: 0x8b85e902  # 139.133.233.2
    # TCP header
    source_port: 0x9005          # 36869
    destination_port: 0x0017     # 23 (TELNET)
    sequence_number: 0x7214f114  # 1913975060
    acknowledgement_number: 0x00000000
    data_offset: 0x6  # 6 x 32 bits = 24 bytes
    reserved: 0b000
    flags: 0b 0 0 0 0 0 0 0 1 0  # SYN
    window_size: 0x2238          # 8760
    checksum: 0xa92c
    urgent_pointer: 0x0000
    options: 0x 0204 05b4
    # Payload
    payload: 0x 11 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "00:e0:f7:26:3f:e9"
    ethernet_source: "08:00:20:86:35:4b"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x002e"
    identification: "0x08b8"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xff"
    protocol: "0x06"
    checksum: "0x9995"
    ipv4_source: "139.133.217.110"
    ipv4_destination: "139.133.233.2"
  }
}
headers {
  tcp_header {
    source_port: "0x9005"
    destination_port: "0x0017"
    sequence_number: "0x7214f114"
    acknowledgement_number: "0x00000000"
    data_offset: "0x6"
    rest_of_header: "0x0022238a92c0000"
    uninterpreted_options: "0x020405b4"
  }
}
payload: "\021\""

================================================================================
Parsing test: ARP Packet (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0x ff ff ff ff ff ff
    ethernet_source: 0x 00 11 22 33 44 55
    ether_type: 0x0806
    # ARP header
    hardware_type: 0x0001  # Ethernet
    protocol_type: 0x0800  # IPv4
    hardware_length: 0x06
    protocol_length: 0x04
    operation: 0x0001  # Request
    sender_hardware_address: 0x 00 11 22 33 44 55
    sender_protocol_address: 0x 0a 00 00 01
    target_hardware_address: 0x 00 00 00 00 00 00
    target_protocol_address: 0x 0a 00 00 02
    # Payload
    payload: 0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "00:11:22:33:44:55"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "00:11:22:33:44:55"
    sender_protocol_address: "10.0.0.1"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "10.0.0.2"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

================================================================================
Parsing test: ICMPv4 Packet (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.erg.abdn.ac.uk/users/gorry/course/inet-pages/packet-dec1.html
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x 08 00 20 86 35 4b
    ethernet_source: 0x 00 e0 f7 26 3f e9
    ether_type: 0x0800
    # IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b000000
    ecn: 0b00
    total_length: 0x0054
    identification: 0xaafb
    flags: 0b010  # website's 0x4 is from interpreting 4 bits.
    fragment_offset: 0b0000000000000
    ttl: 0xfc       # 252
    protocol: 0x01  # ICMP
    checksum: 0xfa30
    ipv4_source: 0x 8b 85 e9 02       # 139.133.233.2
    ipv4_destination: 0x 8b 85 d9 6e  # 139.133.233.110
    # ICMP header
    type: 0x00
    code: 0x00
    checksum: 0x45da
    rest_of_header: 0x 1e 60 00 00
    # payload
    payload: 0x 33 5e 3a b8 00 00 42 ac 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14
    payload: 0x 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29
    payload: 0x 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "08:00:20:86:35:4b"
    ethernet_source: "00:e0:f7:26:3f:e9"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x0054"
    identification: "0xaafb"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xfc"
    protocol: "0x01"
    checksum: "0xfa30"
    ipv4_source: "139.133.233.2"
    ipv4_destination: "139.133.217.110"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0x45da"
    rest_of_header: "0x1e600000"
  }
}
payload: "3^:\270\000\000B\254\010\t\n\013\014\r\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037 !\"#$%&\'()*+,-./01234567"

================================================================================
Parsing test: ICMPv6 Packet (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.cloudshark.org/captures/e98730aee1fb
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x c2 01 51 fa 00 00
    ethernet_source: 0x c2 00 51 fa 00 00
    ethertype: 0x86dd
    # IPv6 header:
    version: 0x6
    dscp: 0b000000
    ecn: 0b00
    flow_label: 0x00000
    payload_length: 0x003c
    next_header: 0x3a  # ICMP
    hop_limit: 0x40
    ipv6_source: 0x20010db8000000120000000000000001
    ipv6_destination: 0x20010db8000000120000000000000002
    # ICMP header:
    type: 0x80
    code: 0x00
    checksum: 0x863c
    rest_of_header: 0x 11 0d 00 00
    # payload
    payload: 0x 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14
    payload: 0x 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29
    payload: 0x 2a 2b 2c 2d 2e 2f 30 31 32 33
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x003c"
    next_header: "0x3a"
    hop_limit: "0x40"
    ipv6_source: "2001:db8:0:12::1"
    ipv6_destination: "2001:db8:0:12::2"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    checksum: "0x863c"
    rest_of_header: "0x110d0000"
  }
}
payload: "\000\001\002\003\004\005\006\007\010\t\n\013\014\r\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037 !\"#$%&\'()*+,-./0123"

================================================================================
Parsing test: VLAN Packet with ARP (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Taken from
    # www.cloudshark.org/captures/e7f1b8c0b434
    # --------------------------------------------------------------------------
    # Ethernet header
    ethernet_destination: 0x ff ff ff ff ff ff
    ethernet_source: 0x 00 19 06 ea b8 c1
    ether_type: 0x8100
    # VLAN header
    priority_code_point: 0b000
    drop_eligibility_indicator: 0b0
    vlan_identifier: 0x07b
    ether_type: 0x0806
    # ARP header
    hardware_type: 0x0001  # Ethernet
    protocol_type: 0x0800  # IPv4
    hardware_length: 0x06
    protocol_length: 0x04
    operation: 0x0002  # Reply
    sender_hardware_address: 0x 00 19 06 ea b8 c1
    sender_protocol_address: 0x c0 a8 7b 01
    target_hardware_address: 0x ff ff ff ff ff ff
    target_protocol_address: 0x c0 a8 7b 01
    # Payload
    payload: 0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "00:19:06:ea:b8:c1"
    ethertype: "0x8100"
  }
}
headers {
  vlan_header {
    priority_code_point: "0x0"
    drop_eligible_indicator: "0x0"
    vlan_identifier: "0x07b"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0002"
    sender_hardware_address: "00:19:06:ea:b8:c1"
    sender_protocol_address: "192.168.123.1"
    target_hardware_address: "ff:ff:ff:ff:ff:ff"
    target_protocol_address: "192.168.123.1"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

================================================================================
Parsing test: CSIG IPv6 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x9900
    # CSIG header
    signal_type: 0b001
    reserved0: 0b0
    signal_value: 0b10001
    locator_metadata: 0b0000000
    ethertype: 0x86dd
    # IPv6 header:
    version: 0x6
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0010
    next_header: 0xfd  # Reserved for experimentation -- payload is arbitrary.
    hop_limit: 0x03
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x9900"
  }
}
headers {
  csig_header {
    signal_type: "0x1"
    reserved0: "0x0"
    signal_value: "0x11"
    locator_metadata: "0x00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0010"
    next_header: "0xfd"
    hop_limit: "0x03"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "\000\021\"3DUfw\210\231\252\273\314\335\356\377"

================================================================================
Parsing test: CSIG IPv6 packet (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x9900
    # CSIG header
    signal_type: 0b001
    reserved0: 0b0
    signal_value: 0b10001
    locator_metadata: 0b0000000
    ethertype: 0x86dd
    # IPv6 header:
    version: 0x4
    dscp: 0b011011
    ecn: 0b01
    flow_label: 0x12345
    payload_length: 0x0000
    next_header: 0x90  # some unassigned protocol
    hop_limit: 0xff
    ipv6_source: 0x00001111222233334444555566667777
    ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
    # other headers:
    payload: 0x12
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x9900"
  }
}
headers {
  csig_header {
    signal_type: "0x1"
    reserved0: "0x0"
    signal_value: "0x11"
    locator_metadata: "0x00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x4"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x90"
    hop_limit: "0xff"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "\022"
reason_not_fully_parsed: "ipv6_header.next_header 0x90: unsupported"
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 45"
reasons_invalid: "in Ipv6Header headers[2]: version: Must be 0x6, but was 0x4 instead."
reasons_invalid: "in Ipv6Header headers[2]: payload_length: Must be 0x0001, but was 0x0000 instead."

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: CSIG IPv6 packet (invalid length)
================================================================================
-- INPUT -----------------------------------------------------------------------
# ethernet header
    ethernet_destination: 0xaabbccddeeff
    ethernet_source: 0x112233445566
    ether_type: 0x9900
    # CSIG header
    signal_type: 0b001
    reserved0: 0b0
    signal_value: 0b10001
    locator_metadata: 0b0000000
    # other headers:
    payload: 0x12
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x9900"
  }
}
payload: "(\200\022"
reasons_invalid: "Packet is too short to parse a CSIG header next. Only 24 bits left, need at least 32."
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 3"
reasons_invalid: "headers[1]: header missing - expected CsigHeader"

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = false
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1]: header missing - expected CsigHeader
================================================================================
Parsing test: PTP in L2 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ethertype: 0x88F7
                       # PTP Header
                       transport_specific: 0x0
                       message_type: 0x0
                       reserved0: 0x0
                       version_ptp: 0x0
                       message_length: 0x0034
                       domain_number: 0x00
                       reserved1: 0x00
                       flags: 0x0000
                       correction_field: 0x0000000000000000
                       reserved2: 0x00000000
                       source_port_identity: 0x00000000000000000000
                       sequence_id: 0x0000
                       control_field: 0x00
                       log_message_interval: 0x00
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x88f7"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0034"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: PTP in L2 packet (short)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ethertype: 0x88F7
                       # PTP Header
                       transport_specific: 0x0
                       message_type: 0x0
                       reserved0: 0x0
                       version_ptp: 0x0
                       message_length: 0x0034
                       domain_number: 0x00
                       reserved1: 0x00
                       flags: 0x0000
                       correction_field: 0x0000000000000000
                       reserved2: 0x00000000
                       source_port_identity: 0x00000000000000000000
                       sequence_id: 0x0000
                       control_field: 0x00
                       log_message_interval: 0x00
                       # Payload - 10 octets (short) - correct is 18
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x88f7"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0034"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\""
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 44"
reasons_invalid: "in PtpHeader headers[1]: message_length: Must be 0x002c, but was 0x0034 instead."

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: Packet too short to parse a GRE header (Invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0x c2 01 51 fa 00 00
    ethernet_source: 0x c2 00 51 fa 00 00
    ethertype: 0x86DD
    # IPv6 header:
    version: 0x6
    dscp: 0b000000
    ecn: 0b00
    flow_label: 0x00000
    payload_length: 0x0001
    next_header: 0x2f  # GRE
    hop_limit: 0x3f
    ipv6_source: 0x2607F8B0C15000100000000000000000
    ipv6_destination: 0x20020A05686007490000000000000000
    # GRE header:
    checksum_present: 0b0
    reserved0: 0b0000000
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x0001"
    next_header: "0x2f"
    hop_limit: "0x3f"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
payload: "\000"
reasons_invalid: "Packet is too short to parse a GRE header next. Only 8 bits left, need at least 32."
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 41"
reasons_invalid: "headers[2]: header missing - expected GreHeader"

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[2]: header missing - expected GreHeader
================================================================================
Parsing test: Packet too short to parse a GRE header with optional fields (Invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
        ethernet_destination: 0x c2 01 51 fa 00 00
        ethernet_source: 0x c2 00 51 fa 00 00
        ethertype: 0x86DD
        # IPv6 header:
        version: 0x6
        dscp: 0b000000
        ecn: 0b00
        flow_label: 0x00000
        payload_length: 0x0004
        next_header: 0x2f  # GRE
        hop_limit: 0x3f
        ipv6_source: 0x2607F8B0C15000100000000000000000
        ipv6_destination: 0x20020A05686007490000000000000000
        # GRE header:
        checksum_present: 0b1
        reserved0: 0b000000000000
        version: 0b000
        protocol_type: 0x0800
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x0004"
    next_header: "0x2f"
    hop_limit: "0x3f"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
payload: "\200\000\010\000"
reasons_invalid: "Packet is too short to parse a GRE header with optional fields. Only 32 bits left, need at least 64."
reasons_invalid: "in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 44"
reasons_invalid: "headers[2]: header missing - expected GreHeader"

PadPacketToMinimumSize(packet) = true
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[2]: header missing - expected GreHeader
================================================================================
Parsing test: GRE Ipv4 Encapsulated with Ipv6 Header (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
    ethernet_destination: 0x c2 01 51 fa 00 00
    ethernet_source: 0x c2 00 51 fa 00 00
    ethertype: 0x86DD
    # IPv6 header:
    version: 0x6
    dscp: 0b000000
    ecn: 0b00
    flow_label: 0x00000
    payload_length: 0x011e
    next_header: 0x2f  # GRE
    hop_limit: 0x3f
    ipv6_source: 0x2607F8B0C15000100000000000000000
    ipv6_destination: 0x20020A05686007490000000000000000
    # GRE header:
    checksum_present: 0b0
    reserved0: 0b000000000000
    version: 0b000
    protocol_type: 0x0800
    # Encapsulated IPv4 header
    version: 0x4
    ihl: 0x5
    dscp: 0b000000
    ecn: 0b00
    total_length: 0x011a
    identification: 0x0000
    flags: 0b000
    fragment_offset: 0b0000000000000
    ttl: 0x3f       # 63
    protocol: 0x01  # ICMP
    checksum: 0x753a
    ipv4_source: 0x 80 00 00 00       # 128.0.0.0
    ipv4_destination: 0x b9 a8 cc 00  # 185.168.204.0
    # ICMP header:
    type: 0x00
    code: 0x00
    checksum: 0x00e4
    rest_of_header: 0x 00 00 00 00
    # Payload
    payload: 0x 74 65 73 74 20 70 61 63 6b 65 74 20 23 35 3a 20 52 4f 55 54 49
    payload: 0x 4e 47 5f 50 49 4e 42 41 4c 4c 4c 33 54 4f 47 52 4f 55 50 5f 46
    payload: 0x 4c 4f 57 3a 20 69 70 76 34 5F 74 61 62 6c 65 5f 65 6e 74 72 79
    payload: 0x 20 09 20 7b 20 6d 61 74 63 68 20 7b 20 76 72 66 5f 69 64 3a 20
    payload: 0x 22 76 72 66 2d 32 31 30 22 20 69 70 76 34 5f 64 73 74 20 7b 20
    payload: 0x 76 61 6c 75 65 3a 20 22 31 38 35 2e 31 36 38 2e 32 30 34 2e 30
    payload: 0x 22 20 70 72 65 66 69 78 5f 6c 65 6e 67 74 68 3a 20 32 38 20 7d
    payload: 0x 20 7d 20 61 63 74 69 6f 6e 20 7b 20 73 65 74 5f 77 63 6d 70 5f
    payload: 0x 67 72 6f 75 70 5f 69 64 5f 61 6e 64 5f 6d 65 74 61 64 61 74 61
    payload: 0x 20 7b 20 77 63 6d 70 5f 67 72 6f 75 70 5f 69 64 3a 20 22 67 72
    payload: 0x 6f 75 70 2d 34 32 39 34 39 33 34 35 37 38 22 20 72 6f 75 74 65
    payload: 0x 5f 6d 65 74 61 64 61 74 61 3a 20 22 30 78 30 31 22 20 7d 20 7d
    payload: 0x 20 7d
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x011e"
    next_header: "0x2f"
    hop_limit: "0x3f"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
headers {
  gre_header {
    checksum_present: "0x0"
    reserved0: "0x000"
    version: "0x0"
    protocol_type: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x011a"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x3f"
    protocol: "0x01"
    checksum: "0x753a"
    ipv4_source: "128.0.0.0"
    ipv4_destination: "185.168.204.0"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0x00e4"
    rest_of_header: "0x00000000"
  }
}
payload: "test packet #5: ROUTING_PINBALLL3TOGROUP_FLOW: ipv4_table_entry \t { match { vrf_id: \"vrf-210\" ipv4_dst { value: \"185.168.204.0\" prefix_length: 28 } } action { set_wcmp_group_id_and_metadata { wcmp_group_id: \"group-4294934578\" route_metadata: \"0x01\" } } }"

================================================================================
Parsing test: GRE Ipv4 Encapsulated with Ipv6 Header with checksum present (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
        ethernet_destination: 0x c2 01 51 fa 00 00
        ethernet_source: 0x c2 00 51 fa 00 00
        ethertype: 0x86DD
        # IPv6 header:
        version: 0x6
        dscp: 0b000000
        ecn: 0b00
        flow_label: 0x00000
        payload_length: 0x0122
        next_header: 0x2f  # GRE
        hop_limit: 0x3f
        ipv6_source: 0x2607F8B0C15000100000000000000000
        ipv6_destination: 0x20020A05686007490000000000000000
        # GRE header:
        checksum_present: 0b1
        reserved0: 0b000000000000
        version: 0b000
        protocol_type: 0x0800
        checksum: 0x77ff
        reserved1: 0x0000
        # Encapsulated IPv4 header
        version: 0x4
        ihl: 0x5
        dscp: 0b000000
        ecn: 0b00
        total_length: 0x011a
        identification: 0x0000
        flags: 0b000
        fragment_offset: 0b0000000000000
        ttl: 0x3f       # 63
        protocol: 0x01  # ICMP
        checksum: 0x753a
        ipv4_source: 0x 80 00 00 00       # 128.0.0.0
        ipv4_destination: 0x b9 a8 cc 00  # 185.168.204.0
        # ICMP header:
        type: 0x00
        code: 0x00
        checksum: 0x00e4
        rest_of_header: 0x 00 00 00 00
        # Payload
        payload:
            0x 74 65 73 74 20 70 61 63 6b 65 74 20 23 35 3a 20 52 4f 55 54 49
        payload:
            0x 4e 47 5f 50 49 4e 42 41 4c 4c 4c 33 54 4f 47 52 4f 55 50 5f 46
        payload:
            0x 4c 4f 57 3a 20 69 70 76 34 5F 74 61 62 6c 65 5f 65 6e 74 72 79
        payload:
            0x 20 09 20 7b 20 6d 61 74 63 68 20 7b 20 76 72 66 5f 69 64 3a 20
        payload:
            0x 22 76 72 66 2d 32 31 30 22 20 69 70 76 34 5f 64 73 74 20 7b 20
        payload:
            0x 76 61 6c 75 65 3a 20 22 31 38 35 2e 31 36 38 2e 32 30 34 2e 30
        payload:
            0x 22 20 70 72 65 66 69 78 5f 6c 65 6e 67 74 68 3a 20 32 38 20 7d
        payload:
            0x 20 7d 20 61 63 74 69 6f 6e 20 7b 20 73 65 74 5f 77 63 6d 70 5f
        payload:
            0x 67 72 6f 75 70 5f 69 64 5f 61 6e 64 5f 6d 65 74 61 64 61 74 61
        payload:
            0x 20 7b 20 77 63 6d 70 5f 67 72 6f 75 70 5f 69 64 3a 20 22 67 72
        payload:
            0x 6f 75 70 2d 34 32 39 34 39 33 34 35 37 38 22 20 72 6f 75 74 65
        payload:
            0x 5f 6d 65 74 61 64 61 74 61 3a 20 22 30 78 30 31 22 20 7d 20 7d
        payload: 0x 20 7d
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x0122"
    next_header: "0x2f"
    hop_limit: "0x3f"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
headers {
  gre_header {
    checksum_present: "0x1"
    reserved0: "0x000"
    version: "0x0"
    protocol_type: "0x0800"
    checksum: "0x77ff"
    reserved1: "0x0000"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x011a"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x3f"
    protocol: "0x01"
    checksum: "0x753a"
    ipv4_source: "128.0.0.0"
    ipv4_destination: "185.168.204.0"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0x00e4"
    rest_of_header: "0x00000000"
  }
}
payload: "test packet #5: ROUTING_PINBALLL3TOGROUP_FLOW: ipv4_table_entry \t { match { vrf_id: \"vrf-210\" ipv4_dst { value: \"185.168.204.0\" prefix_length: 28 } } action { set_wcmp_group_id_and_metadata { wcmp_group_id: \"group-4294934578\" route_metadata: \"0x01\" } } }"

================================================================================
Parsing test: SAI P4 BMv2 packet_in header (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# SAI P4 BMv2 packet_in header
        ingress_port: 0b000000001
        target_egress_port: 0b000000010
        unused_pad: 0b000000
        # Ethernet header
        ethernet_destination: 0x ff ff ff ff ff ff
        ethernet_source: 0x 00 11 22 33 44 55
        ether_type: 0x0806
        # ARP header
        hardware_type: 0x0001  # Ethernet
        protocol_type: 0x0800  # IPv4
        hardware_length: 0x06
        protocol_length: 0x04
        operation: 0x0001  # Request
        sender_hardware_address: 0x 00 11 22 33 44 55
        sender_protocol_address: 0x 0a 00 00 01
        target_hardware_address: 0x 00 00 00 00 00 00
        target_protocol_address: 0x 0a 00 00 02
        # Payload
        payload: 0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
-- OUTPUT ----------------------------------------------------------------------
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0x001"
    target_egress_port: "0x002"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "00:11:22:33:44:55"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "00:11:22:33:44:55"
    sender_protocol_address: "10.0.0.1"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "10.0.0.2"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

================================================================================
Parsing test: SAI P4 BMv2 packet_in header unused_pad value is not 0 (Invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# SAI P4 BMv2 packet_in header
        ingress_port: 0b000000001
        target_egress_port: 0b000000010
        unused_pad: 0b000001
        # Ethernet header
        ethernet_destination: 0x ff ff ff ff ff ff
        ethernet_source: 0x 00 11 22 33 44 55
        ether_type: 0x0806
        # ARP header
        hardware_type: 0x0001  # Ethernet
        protocol_type: 0x0800  # IPv4
        hardware_length: 0x06
        protocol_length: 0x04
        operation: 0x0001  # Request
        sender_hardware_address: 0x 00 11 22 33 44 55
        sender_protocol_address: 0x 0a 00 00 01
        target_hardware_address: 0x 00 00 00 00 00 00
        target_protocol_address: 0x 0a 00 00 02
        # Payload
        payload: 0x 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
-- OUTPUT ----------------------------------------------------------------------
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0x001"
    target_egress_port: "0x002"
    unused_pad: "0x01"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "00:11:22:33:44:55"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "00:11:22:33:44:55"
    sender_protocol_address: "10.0.0.1"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "10.0.0.2"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
reasons_invalid: "in SaiP4BMv2PacketInHeader headers[0]: unused_pad: Must be 0, but was 0x01 instead."

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: unused_pad: Must be 0, but was 0x01 instead.
================================================================================
Parsing test: IPv6-in-IPv6 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ether_type: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0043
                       next_header: 0x29  # IPv6
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x001b
                       next_header: 0xfd  # Experimental
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # Payload.
                       payload: "IPv6-in-IPv6 packet payload"
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0043"
    next_header: "0x29"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x001b"
    next_header: "0xfd"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "IPv6-in-IPv6 packet payload"

================================================================================
Parsing test: IPv4-in-IPv6 packet (valid except for computed fields)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ether_type: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0000
                       next_header: 0x04  # IPv4
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # IPv4 header.
                       version: 0x4
                       ihl: 0x5
                       dscp: 0b011011
                       ecn: 0b01
                       total_length: 0x0000
                       identification: 0x0000
                       flags: 0b000
                       fragment_offset: 0b0000000000000
                       ttl: 0x10
                       protocol: 0xfd  # Experimental
                       checksum: 0x0000
                       ipv4_source: 0xc0a8001f       # 192.168.0.31
                       ipv4_destination: 0xc0a8001e  # 192.168.0.30
                       # Payload.
                       payload: "IPv4-in-IPv6 packet payload"
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x04"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0000"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0xfd"
    checksum: "0x0000"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
payload: "IPv4-in-IPv6 packet payload"
reasons_invalid: "in Ipv6Header headers[1]: payload_length: Must be 0x002f, but was 0x0000 instead."
reasons_invalid: "in Ipv4Header headers[2]: total_length: Must be 0x002f, but was 0x0000 instead."
reasons_invalid: "in Ipv4Header headers[2]: checksum: Must be 0x2807, but was 0x0000 instead."

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: IPv6-in-IPv4 packet (valid except for computed fields)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ether_type: 0x0800
                       # IPv4 header.
                       version: 0x4
                       ihl: 0x5
                       dscp: 0b011011
                       ecn: 0b01
                       total_length: 0x0000
                       identification: 0x0000
                       flags: 0b000
                       fragment_offset: 0b0000000000000
                       ttl: 0x10
                       protocol: 0x29  # IPv6
                       checksum: 0x0000
                       ipv4_source: 0xc0a8001f       # 192.168.0.31
                       ipv4_destination: 0xc0a8001e  # 192.168.0.30
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0000
                       next_header: 0xfd  # Experimental
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # Payload.
                       payload: "IPv6-in-IPv4 packet payload"
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0000"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x29"
    checksum: "0x0000"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0xfd"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
payload: "IPv6-in-IPv4 packet payload"
reasons_invalid: "in Ipv4Header headers[1]: total_length: Must be 0x0057, but was 0x0000 instead."
reasons_invalid: "in Ipv4Header headers[1]: checksum: Must be 0x28db, but was 0x0000 instead."
reasons_invalid: "in Ipv6Header headers[2]: payload_length: Must be 0x001b, but was 0x0000 instead."

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: IPv4-in-IPv4 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ether_type: 0x0800
                       # IPv4 header.
                       version: 0x4
                       ihl: 0x5
                       dscp: 0b011011
                       ecn: 0b01
                       total_length: 0x0043
                       identification: 0x2900
                       flags: 0b000
                       fragment_offset: 0b0000000000000
                       ttl: 0x10
                       protocol: 0x04  # IPv4
                       checksum: 0xffbc
                       ipv4_source: 0xc0a8001f       # 192.168.0.31
                       ipv4_destination: 0xc0a8001e  # 192.168.0.30
                       # IPv4 header.
                       version: 0x4
                       ihl: 0x5
                       dscp: 0b011011
                       ecn: 0b01
                       total_length: 0x002f
                       identification: 0x0000
                       flags: 0b000
                       fragment_offset: 0b0000000000000
                       ttl: 0x10
                       protocol: 0xfd  # Experimental
                       checksum: 0x27d8
                       ipv4_source: 0xc0a8001f       # 192.168.0.31
                       ipv4_destination: 0xc0a8001e  # 192.168.0.30
                       # Payload.
                       payload: "IPv4-in-IPv4 packet payload"
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0043"
    identification: "0x2900"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x04"
    checksum: "0xffbc"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x002f"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0xfd"
    checksum: "0x27d8"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
payload: "IPv4-in-IPv4 packet payload"

================================================================================
Parsing test: PSAMP packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
        ethernet_destination: 0xffeeddccbbaa
        ethernet_source: 0x554433221100
        ether_type: 0x86DD
        # IPv6 header.
        version: 0x6
        dscp: 0b000000
        ecn: 0b00
        flow_label: 0x12345
        payload_length: 0x0046
        next_header: 0x11  # UDP
        hop_limit: 0x42
        ipv6_source: 0x00001111222233334444555566667777
        ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
        # UDP Header
        source_port: 0x08ae       # 2222
        destination_port: 0x1283  # 4739
        length: 0x0046            # 70
        checksum: 0x0000          # Always zero for PSAMP
        # IPFIX Header
        version: 0x000A
        length: 0x003e
        export_time: 0x 64 c1 8c 23  # 1690405923 - 2023-07-26 5:12:03PM EST
        sequence_number: 0x00000001
        observation_domain_id: 0x00000001
        # PSAMP Header
        template_id: 0x0000
        length: 0x002e
        observation_time: 0x 17 75 87 3B 16 A1 9E 00  # 1690405923000000000
        flowset: 0x04D2                               # 1234
        next_hop_index: 0x0000
        epoch: 0xabcd
        ingress_port: 0x000d
        egress_port: 0x000f
        user_meta_field: 0x0000
        dlb_id: 0x00
        variable_length: 0xff
        packet_sampled_length: 0x0012
        # Payload - 18 octets
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0046"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x1283"
    length: "0x0046"
    checksum: "0x0000"
  }
}
headers {
  ipfix_header {
    version: "0x000a"
    length: "0x003e"
    export_time: "0x64c18c23"
    sequence_number: "0x00000001"
    observation_domain_id: "0x00000001"
  }
}
headers {
  psamp_header {
    template_id: "0x0000"
    length: "0x002e"
    observation_time: "0x1775873b16a19e00"
    flowset: "0x04d2"
    next_hop_index: "0x0000"
    epoch: "0xabcd"
    ingress_port: "0x000d"
    egress_port: "0x000f"
    user_meta_field: "0x0000"
    dlb_id: "0x00"
    variable_length: "0xff"
    packet_sampled_length: "0x0012"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: PSAMP packet (valid except for computed fields)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
        ethernet_destination: 0xffeeddccbbaa
        ethernet_source: 0x554433221100
        ether_type: 0x86DD
        # IPv6 header.
        version: 0x6
        dscp: 0b000000
        ecn: 0b00
        flow_label: 0x12345
        payload_length: 0x0000
        next_header: 0x11  # UDP
        hop_limit: 0x42
        ipv6_source: 0x00001111222233334444555566667777
        ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
        # UDP Header
        source_port: 0x08ae       # 2222
        destination_port: 0x1283  # 4739
        length: 0x0000
        checksum: 0x0012  # Always zero for PSAMP
        # IPFIX Header
        version: 0x000A
        length: 0x0000
        export_time: 0x 64 c1 8c 23  # 1690405923 - 2023-07-26 5:12:03PM EST
        sequence_number: 0x00000001
        observation_domain_id: 0x00000001
        # PSAMP Header
        template_id: 0x0000
        length: 0x0000
        observation_time: 0x 17 75 87 3B 16 A1 9E 00  # 1690405923000000000
        flowset: 0x04D2                               # 1234
        next_hop_index: 0x0000
        epoch: 0xabcd
        ingress_port: 0x000d
        egress_port: 0x000f
        user_meta_field: 0x0000
        dlb_id: 0x00
        variable_length: 0xff
        packet_sampled_length: 0x0013
        # Payload - 18 octets
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x1283"
    length: "0x0000"
    checksum: "0x0012"
  }
}
headers {
  ipfix_header {
    version: "0x000a"
    length: "0x0000"
    export_time: "0x64c18c23"
    sequence_number: "0x00000001"
    observation_domain_id: "0x00000001"
  }
}
headers {
  psamp_header {
    template_id: "0x0000"
    length: "0x0000"
    observation_time: "0x1775873b16a19e00"
    flowset: "0x04d2"
    next_hop_index: "0x0000"
    epoch: "0xabcd"
    ingress_port: "0x000d"
    egress_port: "0x000f"
    user_meta_field: "0x0000"
    dlb_id: "0x00"
    variable_length: "0xff"
    packet_sampled_length: "0x0013"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
reasons_invalid: "in Ipv6Header headers[1]: payload_length: Must be 0x0046, but was 0x0000 instead."
reasons_invalid: "in UdpHeader headers[2]: length: Must be 0x0046, but was 0x0000 instead."
reasons_invalid: "in UdpHeader headers[2]: checksum: Must be 0xbb79, but was 0x0012 instead."
reasons_invalid: "in IpfixHeader headers[3]: length: Must be 0x003e, but was 0x0000 instead."
reasons_invalid: "in PsampHeader headers[4]: length: Must be 0x002e, but was 0x0000 instead."
reasons_invalid: "in PsampHeader headers[4]: packet_sampled_length: Must be 0x0012, but was 0x0013 instead."

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: PTP event packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x003c
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP Header
                       source_port: 0x08ae       # 2222
                       destination_port: 0x013f  # 319
                       length: 0x003c
                       checksum: 0x0000
                       # PTP Header
                       transport_specific: 0x0
                       message_type: 0x0
                       reserved0: 0x0
                       version_ptp: 0x0
                       message_length: 0x0034
                       domain_number: 0x00
                       reserved1: 0x00
                       flags: 0x0000
                       correction_field: 0x0000000000000000
                       reserved2: 0x00000000
                       source_port_identity: 0x00000000000000000000
                       sequence_id: 0x0000
                       control_field: 0x00
                       log_message_interval: 0x00
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003c"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003c"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0034"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: PTP general packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x003c
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP Header
                       source_port: 0x08ae       # 2222
                       destination_port: 0x0140  # 320
                       length: 0x003c
                       checksum: 0x0000
                       # PTP Header
                       transport_specific: 0x0
                       message_type: 0x0
                       reserved0: 0x0
                       version_ptp: 0x0
                       message_length: 0x0034
                       domain_number: 0x00
                       reserved1: 0x00
                       flags: 0x0000
                       correction_field: 0x0000000000000000
                       reserved2: 0x00000000
                       source_port_identity: 0x00000000000000000000
                       sequence_id: 0x0000
                       control_field: 0x00
                       log_message_interval: 0x00
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003c"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x0140"
    length: "0x003c"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0034"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: PTP packet is too short (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header.
                       ethernet_destination: 0xffeeddccbbaa
                       ethernet_source: 0x554433221100
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0029
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP Header
                       source_port: 0x08ae       # 2222
                       destination_port: 0x013f  # 319
                       length: 0x0029
                       checksum: 0xf57b
                       # PTP Header
                       transport_specific: 0x0
                       message_type: 0x0
                       reserved0: 0x0
                       version_ptp: 0x0
                       message_length: 0x0034
                       domain_number: 0x00
                       reserved1: 0x00
                       flags: 0x0000
                       correction_field: 0x0000000000000000
                       reserved2: 0x00000000
                       source_port_identity: 0x00000000000000000000
                       sequence_id: 0x0000
                       control_field: 0x00
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0029"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x0029"
    checksum: "0xf57b"
  }
}
payload: "\000\000\0004\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
reasons_invalid: "Packet is too short to parse a PTP header next. Only 264 bits left, need at least 272."
reasons_invalid: "headers[3]: header missing - expected PtpHeader"

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[3]: header missing - expected PtpHeader
================================================================================
Parsing test: Inner and outer UDP checksums can both be zero (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
                       ethernet_destination: 0xaabbccddeeff
                       ethernet_source: 0x112233445566
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0032
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP header
                       source_port: 0x0014
                       destination_port: 0x03e8  # 1000
                       length: 0x0032
                       checksum: 0x0000
                       # PSP Header
                       next_header: 0x11  # UDP
                       header_ext_length: 0x00
                       reserved0: 0b00
                       crypt_offset: 0b000010
                       sample_bit: 0b0
                       drop_bit: 0b0
                       version: 0x1
                       virtualization_cookie_present: 0b0
                       reserved1: 0b1
                       security_parameters_index: 0x00000000
                       initialization_vector: 0x0000000000000000
                       # Inner UDP Header
                       source_port: 0xbeef
                       destination_port: 0xabcd
                       length: 0x001a
                       checksum: 0x0000
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0032"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x0032"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001a"
    checksum: "0x0000"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: Inner UDP checksum can be anything, but the outer checksum must be correct (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
        ethernet_destination: 0xaabbccddeeff
        ethernet_source: 0x112233445566
        ethertype: 0x86DD
        # IPv6 header.
        version: 0x6
        dscp: 0b000000
        ecn: 0b00
        flow_label: 0x12345
        payload_length: 0x0032
        next_header: 0x11  # UDP
        hop_limit: 0x42
        ipv6_source: 0x00001111222233334444555566667777
        ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
        # UDP header
        source_port: 0x0014
        destination_port: 0x03e8  # 1000
        length: 0x0032
        checksum: 0x4a7d
        # PSP Header
        next_header: 0x11  # UDP
        header_ext_length: 0x00
        reserved0: 0b00
        crypt_offset: 0b000010
        sample_bit: 0b0
        drop_bit: 0b0
        version: 0x1
        virtualization_cookie_present: 0b0
        reserved1: 0b1
        security_parameters_index: 0x00000000
        initialization_vector: 0x0000000000000000
        # Inner UDP Header
        source_port: 0xbeef
        destination_port: 0xabcd
        length: 0x001a
        checksum: 0x0002
        # Payload - 18 octets
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0032"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x0032"
    checksum: "0x4a7d"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001a"
    checksum: "0x0002"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: Inner UDP checksum can be anything, but the outer checksum must be correct (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
        ethernet_destination: 0xaabbccddeeff
        ethernet_source: 0x112233445566
        ethertype: 0x86DD
        # IPv6 header.
        version: 0x6
        dscp: 0b000000
        ecn: 0b00
        flow_label: 0x12345
        payload_length: 0x0032
        next_header: 0x11  # UDP
        hop_limit: 0x42
        ipv6_source: 0x00001111222233334444555566667777
        ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
        # UDP header
        source_port: 0x0014
        destination_port: 0x03e8  # 1000
        length: 0x0032
        checksum: 0x0001
        # PSP Header
        next_header: 0x11  # UDP
        header_ext_length: 0x00
        reserved0: 0b00
        crypt_offset: 0b000010
        sample_bit: 0b0
        drop_bit: 0b0
        version: 0x1
        virtualization_cookie_present: 0b0
        reserved1: 0b1
        security_parameters_index: 0x00000000
        initialization_vector: 0x0000000000000000
        # Inner UDP Header
        source_port: 0xbeef
        destination_port: 0xabcd
        length: 0x001a
        checksum: 0x0001
        # Payload - 18 octets
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22 22 22 22 22 22 22
        payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0032"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x0032"
    checksum: "0x0001"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001a"
    checksum: "0x0001"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
reasons_invalid: "in UdpHeader headers[2]: checksum: Must be 0x4a7e, but was 0x0001 instead."

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = OK
================================================================================
Parsing test: PSP packet unencrypted UDP (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
                       ethernet_destination: 0xaabbccddeeff
                       ethernet_source: 0x112233445566
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0032
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP header
                       source_port: 0x0014
                       destination_port: 0x03e8  # 1000
                       length: 0x0032
                       checksum: 0x0000
                       # PSP Header
                       next_header: 0x11  # UDP
                       header_ext_length: 0x00
                       reserved0: 0b00
                       crypt_offset: 0b000010
                       sample_bit: 0b0
                       drop_bit: 0b0
                       version: 0x1
                       virtualization_cookie_present: 0b0
                       reserved1: 0b1
                       security_parameters_index: 0x00000000
                       initialization_vector: 0x0000000000000000
                       # Inner UDP Header
                       source_port: 0xbeef
                       destination_port: 0xabcd
                       length: 0x001a
                       checksum: 0x0025
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0032"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x0032"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001a"
    checksum: "0x0025"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: PSP packet with encrypted UDP (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
                       ethernet_destination: 0xaabbccddeeff
                       ethernet_source: 0x112233445566
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x002a
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP header
                       source_port: 0x0014
                       destination_port: 0x03e8  # 1000
                       length: 0x002a
                       checksum: 0x0000
                       # PSP Header
                       next_header: 0x11  # UDP
                       header_ext_length: 0x00
                       reserved0: 0b00
                       crypt_offset: 0b000000
                       sample_bit: 0b0
                       drop_bit: 0b0
                       version: 0x1
                       virtualization_cookie_present: 0b0
                       reserved1: 0b1
                       security_parameters_index: 0x00000000
                       initialization_vector: 0x0000000000000000
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x002a"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x002a"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x00"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""

================================================================================
Parsing test: PSP packet with virtualization cookie (unsupported)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
                       ethernet_destination: 0xaabbccddeeff
                       ethernet_source: 0x112233445566
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x002a
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP header
                       source_port: 0x0014
                       destination_port: 0x03e8  # 1000
                       length: 0x002a
                       checksum: 0x0000
                       # PSP Header
                       next_header: 0x04
                       header_ext_length: 0x00
                       reserved0: 0b00
                       crypt_offset: 0b000000
                       sample_bit: 0b0
                       drop_bit: 0b0
                       version: 0x1
                       virtualization_cookie_present: 0b1
                       reserved1: 0b1
                       security_parameters_index: 0x00000000
                       initialization_vector: 0x0000000000000000
                       # Payload - 18 octets
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22 22 22 22 22 22 22
                       payload: 0x 22 22
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x002a"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x002a"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x04"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x00"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x1"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
payload: "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
reason_not_fully_parsed: "psp_header virtualization_cookie is not supported."

================================================================================
Parsing test: PSP packet that is too short (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
# Ethernet header
                       ethernet_destination: 0xaabbccddeeff
                       ethernet_source: 0x112233445566
                       ethertype: 0x86DD
                       # IPv6 header.
                       version: 0x6
                       dscp: 0b000000
                       ecn: 0b00
                       flow_label: 0x12345
                       payload_length: 0x0010
                       next_header: 0x11  # UDP
                       hop_limit: 0x42
                       ipv6_source: 0x00001111222233334444555566667777
                       ipv6_destination: 0x88889999aaaabbbbccccddddeeeeffff
                       # UDP header
                       source_port: 0x0014
                       destination_port: 0x03e8  # 1000
                       length: 0x0010
                       checksum: 0x0000
                       # PSP Header
                       next_header: 0x11  # UDP
                       header_ext_length: 0x00
                       reserved0: 0b00
                       crypt_offset: 0b000000
                       sample_bit: 0b0
                       drop_bit: 0b0
                       version: 0x1
                       virtualization_cookie_present: 0b0
                       reserved1: 0b1
                       security_parameters_index: 0x00000000
-- OUTPUT ----------------------------------------------------------------------
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0010"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "0:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x03e8"
    length: "0x0010"
    checksum: "0x0000"
  }
}
payload: "\021\000\000\005\000\000\000\000"
reasons_invalid: "Packet is too short to parse a PSP header next. Only 64 bits left, need at least 128."
reasons_invalid: "headers[3]: header missing - expected PspHeader"

PadPacketToMinimumSize(packet) = false
UpdateAllComputedFields(packet) = true
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[3]: header missing - expected PspHeader
================================================================================
Proto packet test: UDP header not preceded by other header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x000a"
    checksum: "0x35c5"
  }
}
payload: "Hi"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[0]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: UDP header must be preceded by an IP or PSP header, but no header was found

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[0]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: UDP header must be preceded by an IP or PSP header, but no header was found

================================================================================
Proto packet test: UDP header not preceded by IP header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x000a"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x000a"
    checksum: "0x35c5"
  }
}
payload: "Hi"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[1]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: UDP header must be preceded by an IP or PSP header, but got EthernetHeader
- in UdpHeader headers[1]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

PadPacketToMinimumSize(packet) = true
new payload: "Hi\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: ethertype: value 0x000a is <= 1500 and should thus match payload size, but payload size is 46 bytes
- in UdpHeader headers[1]: length: Must be 0x002e, but was 0x000a instead.
- in UdpHeader headers[1]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: UDP header must be preceded by an IP or PSP header, but got EthernetHeader
- in UdpHeader headers[1]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

================================================================================
Proto packet test: UDP header empty length and checksum
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x11"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
  }
}
payload: "Some random payload."

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: total_length: missing
- in Ipv4Header headers[1]: checksum: missing
- in UdpHeader headers[2]: length: missing
- in UdpHeader headers[2]: checksum: missing

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0030"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x11"
    checksum: "0x28c3"
    ipv4_source: "192.168.0.31"
    ipv4_destination: "192.168.0.30"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x001c"
    checksum: "0xac67"
  }
}
payload: "Some random payload."

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: UDP header illegally succeeding IPv6 header whose next_header is not UDP
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x000a"
    next_header: "0x90"
    hop_limit: "0x03"
    ipv6_source: "0000:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
  }
}
payload: "Hi"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[2]: length: missing
- in UdpHeader headers[2]: checksum: missing
- in UdpHeader headers[2]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x000a"
    next_header: "0x90"
    hop_limit: "0x03"
    ipv6_source: "0000:1111:2222:3333:4444:5555:6666:7777"
    ipv6_destination: "8888:9999:aaaa:bbbb:cccc:dddd:eeee:ffff"
  }
}
headers {
  udp_header {
    source_port: "0x0014"
    destination_port: "0x000a"
    length: "0x000a"
    checksum: "0xb753"
  }
}
payload: "Hi"

ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[2]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[2]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

================================================================================
Proto packet test: TCP header whose options field is not word-aligned
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  tcp_header {
    source_port: "0x0001"
    destination_port: "0x0002"
    sequence_number: "0x00000001"
    acknowledgement_number: "0x00000000"
    rest_of_header: "0x000000000000000"
    uninterpreted_options: "0x00"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in TcpHeader headers[0]: data_offset: missing
- in TcpHeader headers[0]: uninterpreted_options: found 8 bits, but expected multiple of 32 bits

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = INVALID_ARGUMENT: TcpHeader: failed to compute packet.headers[0].data_offset: comuted offset of 168 bits is not a multiple of 32 bits; this indicates that uninterpreted_options is of invalid length

Serialize(Packet) = INVALID_ARGUMENT: TcpHeader: failed to compute packet.headers[0].data_offset: comuted offset of 168 bits is not a multiple of 32 bits; this indicates that uninterpreted_options is of invalid length

================================================================================
Proto packet test: TCP header whose options field is too long
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  tcp_header {
    source_port: "0x0001"
    destination_port: "0x0002"
    sequence_number: "0x00000001"
    acknowledgement_number: "0x00000000"
    rest_of_header: "0x000000000000000"
    uninterpreted_options: "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in TcpHeader headers[0]: data_offset: missing
- in TcpHeader headers[0]: uninterpreted_options: found 11 32-bit words, but at most 10 are allowed

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = INVALID_ARGUMENT: data_offset: computed offset of 16 is outside of legal range [5, 15]; this indicates that uninterpreted_options is of invalid length

Serialize(Packet) = INVALID_ARGUMENT: data_offset: computed offset of 16 is outside of legal range [5, 15]; this indicates that uninterpreted_options is of invalid length

================================================================================
Proto packet test: IPv4 without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    dscp: "0x1b"
    ecn: "0x1"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "payloads everywhere"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 39
- in Ipv4Header headers[1]: version: missing
- in Ipv4Header headers[1]: ihl: missing
- in Ipv4Header headers[1]: total_length: missing
- in Ipv4Header headers[1]: checksum: missing

PadPacketToMinimumSize(packet) = true
new payload: "payloads everywhere\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x002e"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe88d"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "payloads everywhere\000\000\000\000\000\000\000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: Ipv4 empty ihl, invalid options
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    dscp: "0x1b"
    ecn: "0x1"
    total_length: "0x0025"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "10.0.0.1"
    ipv4_destination: "20.0.0.3"
    uninterpreted_options: "0x12"
  }
}
payload: "A somewhat longer payload."

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: ihl: missing
- in Ipv4Header headers[1]: uninterpreted_options: found 8 bits, but expected multiple of 32 bits
- in Ipv4Header headers[1]: total_length: Must be 0x002f, but was 0x0025 instead.
- in Ipv4Header headers[1]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: missing '0x'-prefix in hexadecimal string: ''

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = INVALID_ARGUMENT: Ipv4Header: failed to compute packet.headers[1].ihl: uninterpreted_options field is invalid

Serialize(Packet) = INVALID_ARGUMENT: Ipv4Header: failed to compute packet.headers[1].ihl: uninterpreted_options field is invalid

================================================================================
Proto packet test: Ipv4 empty ihl, valid options
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    dscp: "0x011011"
    ecn: "0x01"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x000"
    fragment_offset: "0x0000000000000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "0x0a000001"
    ipv4_destination: "0x14000003"
    uninterpreted_options: "0x12345678"
  }
}
payload: "A somewhat longer payload."

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: ihl: missing
- in Ipv4Header headers[1]: dscp: invalid format: illegal conversion from hex string '0x011011' to 6 bits; expected 2 hex digits but got 6
- in Ipv4Header headers[1]: ecn: invalid format: illegal conversion from hex string '0x01' to 2 bits; expected 1 hex digits but got 2
- in Ipv4Header headers[1]: flags: invalid format: illegal conversion from hex string '0x000' to 3 bits; expected 1 hex digits but got 3
- in Ipv4Header headers[1]: fragment_offset: invalid format: illegal conversion from hex string '0x0000000000000' to 13 bits; expected 4 hex digits but got 13
- in Ipv4Header headers[1]: ipv4_source: invalid format: Invalid IPv4 address: '0x0a000001'
- in Ipv4Header headers[1]: ipv4_destination: invalid format: Invalid IPv4 address: '0x14000003'
- in Ipv4Header headers[1]: total_length: Must be 0x0032, but was 0x0034 instead.
- in Ipv4Header headers[1]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: missing '0x'-prefix in hexadecimal string: ''

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x6"
    dscp: "0x011011"
    ecn: "0x01"
    total_length: "0x0034"
    identification: "0xa3cd"
    flags: "0x000"
    fragment_offset: "0x0000000000000"
    ttl: "0x10"
    protocol: "0x05"
    checksum: "0xe887"
    ipv4_source: "0x0a000001"
    ipv4_destination: "0x14000003"
    uninterpreted_options: "0x12345678"
  }
}
payload: "A somewhat longer payload."

ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: dscp: invalid format: illegal conversion from hex string '0x011011' to 6 bits; expected 2 hex digits but got 6
- in Ipv4Header headers[1]: ecn: invalid format: illegal conversion from hex string '0x01' to 2 bits; expected 1 hex digits but got 2
- in Ipv4Header headers[1]: flags: invalid format: illegal conversion from hex string '0x000' to 3 bits; expected 1 hex digits but got 3
- in Ipv4Header headers[1]: fragment_offset: invalid format: illegal conversion from hex string '0x0000000000000' to 13 bits; expected 4 hex digits but got 13
- in Ipv4Header headers[1]: ipv4_source: invalid format: Invalid IPv4 address: '0x0a000001'
- in Ipv4Header headers[1]: ipv4_destination: invalid format: Invalid IPv4 address: '0x14000003'
- in Ipv4Header headers[1]: total_length: Must be 0x0032, but was 0x0034 instead.
- in Ipv4Header headers[1]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: illegal conversion from hex string '0x011011' to 6 bits; expected 2 hex digits but got 6

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: dscp: invalid format: illegal conversion from hex string '0x011011' to 6 bits; expected 2 hex digits but got 6
- in Ipv4Header headers[1]: ecn: invalid format: illegal conversion from hex string '0x01' to 2 bits; expected 1 hex digits but got 2
- in Ipv4Header headers[1]: flags: invalid format: illegal conversion from hex string '0x000' to 3 bits; expected 1 hex digits but got 3
- in Ipv4Header headers[1]: fragment_offset: invalid format: illegal conversion from hex string '0x0000000000000' to 13 bits; expected 4 hex digits but got 13
- in Ipv4Header headers[1]: ipv4_source: invalid format: Invalid IPv4 address: '0x0a000001'
- in Ipv4Header headers[1]: ipv4_destination: invalid format: Invalid IPv4 address: '0x14000003'
- in Ipv4Header headers[1]: total_length: Must be 0x0032, but was 0x0034 instead.
- in Ipv4Header headers[1]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: illegal conversion from hex string '0x011011' to 6 bits; expected 2 hex digits but got 6

================================================================================
Proto packet test: IPv4 with various invalid fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x3"
    ihl: "0x6k"
    dscp: "0x1b"
    ecn: "0x1"
    identification: "0xa3cd"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x10"
    protocol: "0x05"
    ipv4_source: "ffff:1::"
    ipv4_destination: "20.0.0.3"
  }
}
payload: "Hi"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: ethernet_source: missing
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 22
- in Ipv4Header headers[1]: ihl: invalid format: illegal conversion from hex string '0x6k' to 4 bits; expected 1 hex digits but got 2
- in Ipv4Header headers[1]: total_length: missing
- in Ipv4Header headers[1]: checksum: missing
- in Ipv4Header headers[1]: ipv4_source: invalid format: Invalid IPv4 address: 'ffff:1::'
- in Ipv4Header headers[1]: version: Must be 0x4, but was 0x3 instead.

PadPacketToMinimumSize(packet) = true
new payload: "Hi\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = INVALID_ARGUMENT: Ipv4Header: failed to compute packet.headers[1].checksum: illegal conversion from hex string '0x6k' to 4 bits; expected 1 hex digits but got 2

Serialize(Packet) = INVALID_ARGUMENT: Ipv4Header: failed to compute packet.headers[1].checksum: illegal conversion from hex string '0x6k' to 4 bits; expected 1 hex digits but got 2

================================================================================
Proto packet test: IPv6 without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    next_header: "0x05"
    hop_limit: "0x10"
    ipv6_source: "::"
    ipv6_destination: "f::f"
  }
}
payload: "Hello"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 45
- in Ipv6Header headers[1]: version: missing
- in Ipv6Header headers[1]: payload_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "Hello\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0006"
    next_header: "0x05"
    hop_limit: "0x10"
    ipv6_source: "::"
    ipv6_destination: "f::f"
  }
}
payload: "Hello\000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: IPv6 with various invalid fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x4"
    dscp: "1b"
    ecn: "0b01"
    flow_label: "0x1234"
    payload_length: "0x0000"
    next_header: "0x050"
    hop_limit: "0x1"
    ipv6_source: "20.0.0.3"
    ipv6_destination: ":"
  }
}
payload: "I am the payload"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv6Header headers[1]: dscp: invalid format: missing '0x'-prefix in hexadecimal string: '1b'
- in Ipv6Header headers[1]: ecn: invalid format: missing '0x'-prefix in hexadecimal string: '0b01'
- in Ipv6Header headers[1]: flow_label: invalid format: illegal conversion from hex string '0x1234' to 20 bits; expected 5 hex digits but got 4
- in Ipv6Header headers[1]: next_header: invalid format: illegal conversion from hex string '0x050' to 8 bits; expected 2 hex digits but got 3
- in Ipv6Header headers[1]: hop_limit: invalid format: illegal conversion from hex string '0x1' to 8 bits; expected 2 hex digits but got 1
- in Ipv6Header headers[1]: ipv6_source: invalid format: invalid IPv6 address: '20.0.0.3'
- in Ipv6Header headers[1]: ipv6_destination: invalid format: invalid IPv6 address: ':'
- in Ipv6Header headers[1]: version: Must be 0x6, but was 0x4 instead.
- in Ipv6Header headers[1]: payload_length: Must be 0x0010, but was 0x0000 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv6Header headers[1]: dscp: invalid format: missing '0x'-prefix in hexadecimal string: '1b'
- in Ipv6Header headers[1]: ecn: invalid format: missing '0x'-prefix in hexadecimal string: '0b01'
- in Ipv6Header headers[1]: flow_label: invalid format: illegal conversion from hex string '0x1234' to 20 bits; expected 5 hex digits but got 4
- in Ipv6Header headers[1]: next_header: invalid format: illegal conversion from hex string '0x050' to 8 bits; expected 2 hex digits but got 3
- in Ipv6Header headers[1]: hop_limit: invalid format: illegal conversion from hex string '0x1' to 8 bits; expected 2 hex digits but got 1
- in Ipv6Header headers[1]: ipv6_source: invalid format: invalid IPv6 address: '20.0.0.3'
- in Ipv6Header headers[1]: ipv6_destination: invalid format: invalid IPv6 address: ':'
- in Ipv6Header headers[1]: version: Must be 0x6, but was 0x4 instead.
- in Ipv6Header headers[1]: payload_length: Must be 0x0010, but was 0x0000 instead.

================================================================================
Proto packet test: IPv6 packet with IPv4 ethertype
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0800"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x1b"
    ecn: "0x1"
    flow_label: "0x12345"
    payload_length: "0x0000"
    next_header: "0x05"
    hop_limit: "0x10"
    ipv6_source: "::"
    ipv6_destination: "f::f"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 40
- in Ipv6Header headers[1]: expected Ipv4Header (because the previous header demands it), got Ipv6Header

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv6Header headers[1]: payload_length: Must be 0x0006, but was 0x0000 instead.
- in Ipv6Header headers[1]: expected Ipv4Header (because the previous header demands it), got Ipv6Header

================================================================================
Proto packet test: IPv6 packet without IPv6 header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "aa:bb:cc:dd:ee:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x86dd"
  }
}
payload: "hi"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 2
- headers[1]: header missing - expected Ipv6Header

PadPacketToMinimumSize(packet) = true
new payload: "hi\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1]: header missing - expected Ipv6Header

================================================================================
Proto packet test: ARP packet without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 28
- in ArpHeader headers[1]: hardware_type: missing
- in ArpHeader headers[1]: protocol_type: missing
- in ArpHeader headers[1]: hardware_length: missing
- in ArpHeader headers[1]: protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: ARP packet with unsupported computed field values
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0002"
    protocol_type: "0x0801"
    hardware_length: "0x07"
    protocol_length: "0x05"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 28
- in ArpHeader headers[1]: hardware_type: Must be 0x0001, but was 0x0002 instead.
- in ArpHeader headers[1]: protocol_type: Must be 0x0800, but was 0x0801 instead.
- in ArpHeader headers[1]: hardware_length: Must be 0x06, but was 0x07 instead.
- in ArpHeader headers[1]: hardware_type: Must be 0x04, but was 0x05 instead.

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in ArpHeader headers[1]: hardware_type: Must be 0x0001, but was 0x0002 instead.
- in ArpHeader headers[1]: protocol_type: Must be 0x0800, but was 0x0801 instead.
- in ArpHeader headers[1]: hardware_length: Must be 0x06, but was 0x07 instead.
- in ArpHeader headers[1]: hardware_type: Must be 0x04, but was 0x05 instead.

================================================================================
Proto packet test: ICMPv4 packet without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "08:00:20:86:35:4b"
    ethernet_source: "00:e0:f7:26:3f:e9"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    dscp: "0x00"
    ecn: "0x0"
    identification: "0xaafb"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xfc"
    protocol: "0x01"
    ipv4_source: "139.133.233.2"
    ipv4_destination: "139.133.217.110"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    rest_of_header: "0x1e600000"
  }
}
payload: "ICMPv4 packet without computed fields"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv4Header headers[1]: version: missing
- in Ipv4Header headers[1]: ihl: missing
- in Ipv4Header headers[1]: total_length: missing
- in Ipv4Header headers[1]: checksum: missing
- in IcmpHeader headers[2]: checksum: missing

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "08:00:20:86:35:4b"
    ethernet_source: "00:e0:f7:26:3f:e9"
    ethertype: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x0041"
    identification: "0xaafb"
    flags: "0x2"
    fragment_offset: "0x0000"
    ttl: "0xfc"
    protocol: "0x01"
    checksum: "0xfa43"
    ipv4_source: "139.133.233.2"
    ipv4_destination: "139.133.217.110"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0x8f2d"
    rest_of_header: "0x1e600000"
  }
}
payload: "ICMPv4 packet without computed fields"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: ICMPv6 packet without computed fields
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    next_header: "0x3a"
    hop_limit: "0x40"
    ipv6_source: "2001:db8:0:12::1"
    ipv6_destination: "2001:db8:0:12::2"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    rest_of_header: "0x110d0000"
  }
}
payload: "ICMPv6 packet without computed fields"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv6Header headers[1]: version: missing
- in Ipv6Header headers[1]: payload_length: missing
- in IcmpHeader headers[2]: checksum: missing

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x002d"
    next_header: "0x3a"
    hop_limit: "0x40"
    ipv6_source: "2001:db8:0:12::1"
    ipv6_destination: "2001:db8:0:12::2"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    checksum: "0xc07d"
    rest_of_header: "0x110d0000"
  }
}
payload: "ICMPv6 packet without computed fields"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: ICMP packet without a preceding IP header
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  icmp_header {
    type: "0x80"
    code: "0x00"
    rest_of_header: "0x110d0000"
  }
}
payload: "ICMP packet without a preceding IP header"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in IcmpHeader headers[1]: checksum: missing
- in IcmpHeader headers[1]: checksum: ICMP header must be preceded by IP header for checksum to be defined; found EthernetHeader at headers[0] instead
- in IcmpHeader headers[1]: expected Ipv6Header (because the previous header demands it), got IcmpHeader

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = INVALID_ARGUMENT: IcmpHeaderChecksum(packet, icmp_header_index = 1): expected packet.headers[udp_header_index - 1] to be an IP header, got EthernetHeader

Serialize(Packet) = INVALID_ARGUMENT: IcmpHeaderChecksum(packet, icmp_header_index = 1): expected packet.headers[udp_header_index - 1] to be an IP header, got EthernetHeader

================================================================================
Proto packet test: VLAN ARP packet
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x8100"
  }
}
headers {
  vlan_header {
    priority_code_point: "0x0"
    drop_eligible_indicator: "0x1"
    vlan_identifier: "0x123"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 32
- in ArpHeader headers[2]: hardware_type: missing
- in ArpHeader headers[2]: protocol_type: missing
- in ArpHeader headers[2]: hardware_length: missing
- in ArpHeader headers[2]: protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x8100"
  }
}
headers {
  vlan_header {
    priority_code_point: "0x0"
    drop_eligible_indicator: "0x1"
    vlan_identifier: "0x123"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: Uninitialized (empty packet) - should be invalid
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- Packet is empty.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- Packet is empty.

================================================================================
Proto packet test: GRE Ipv4 Encapsulated with Ipv6 Header (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "c2:01:51:fa:00:00"
    ethernet_source: "c2:00:51:fa:00:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x00000"
    payload_length: "0x011e"
    next_header: "0x2f"
    hop_limit: "0x3f"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
headers {
  gre_header {
    checksum_present: "0x0"
    reserved0: "0x000"
    version: "0x0"
    protocol_type: "0x0800"
  }
}
headers {
  ipv4_header {
    version: "0x4"
    ihl: "0x5"
    dscp: "0x00"
    ecn: "0x0"
    total_length: "0x011a"
    identification: "0x0000"
    flags: "0x0"
    fragment_offset: "0x0000"
    ttl: "0x3f"
    protocol: "0x01"
    checksum: "0x753a"
    ipv4_source: "128.0.0.0"
    ipv4_destination: "185.168.204.0"
  }
}
headers {
  icmp_header {
    type: "0x00"
    code: "0x00"
    checksum: "0x00e4"
    rest_of_header: "0x00000000"
  }
}
payload: "test packet #5: ROUTING_PINBALLL3TOGROUP_FLOW: ipv4_table_entry \t { match { vrf_id: \"vrf-210\" ipv4_dst { value: \"185.168.204.0\" prefix_length: 28 } } action { set_wcmp_group_id_and_metadata { wcmp_group_id: \"group-4294934578\" route_metadata: \"0x01\" } } }"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: SAI P4 BMv2 packet_in Header (Valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0x001"
    target_egress_port: "0x002"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[1]: expected at least 46 bytes of Ethernet payload, but got only 28
- in ArpHeader headers[2]: hardware_type: missing
- in ArpHeader headers[2]: protocol_type: missing
- in ArpHeader headers[2]: hardware_length: missing
- in ArpHeader headers[2]: protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0x001"
    target_egress_port: "0x002"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: SAI P4 BMv2 packet_in Header ingress_port number out of range (Invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0xf00"
    target_egress_port: "0x002"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: ingress_port: invalid format: hex string '0xf00' has bit #10 set to 1; conversion to 9 bits would lose information
- in EthernetHeader headers[1]: expected at least 46 bytes of Ethernet payload, but got only 28
- in ArpHeader headers[2]: hardware_type: missing
- in ArpHeader headers[2]: protocol_type: missing
- in ArpHeader headers[2]: hardware_length: missing
- in ArpHeader headers[2]: protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0xf00"
    target_egress_port: "0x002"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: ingress_port: invalid format: hex string '0xf00' has bit #10 set to 1; conversion to 9 bits would lose information

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: ingress_port: invalid format: hex string '0xf00' has bit #10 set to 1; conversion to 9 bits would lose information

================================================================================
Proto packet test: SAI P4 BMv2 packet_in Header target_egress_port number out of range (Invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0x001"
    target_egress_port: "0xf00"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: target_egress_port: invalid format: hex string '0xf00' has bit #10 set to 1; conversion to 9 bits would lose information
- in EthernetHeader headers[1]: expected at least 46 bytes of Ethernet payload, but got only 28
- in ArpHeader headers[2]: hardware_type: missing
- in ArpHeader headers[2]: protocol_type: missing
- in ArpHeader headers[2]: hardware_length: missing
- in ArpHeader headers[2]: protocol_length: missing

PadPacketToMinimumSize(packet) = true
new payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

UpdateMissingComputedFields(packet) = true
packet =
headers {
  sai_p4_bmv2_packet_in_header {
    ingress_port: "0x001"
    target_egress_port: "0xf00"
    unused_pad: "0x00"
  }
}
headers {
  ethernet_header {
    ethernet_destination: "ff:ff:ff:ff:ff:ff"
    ethernet_source: "11:22:33:44:55:66"
    ethertype: "0x0806"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "11:22:33:44:55:66"
    sender_protocol_address: "1.2.3.4"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "1.2.3.5"
  }
}
payload: "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: target_egress_port: invalid format: hex string '0xf00' has bit #10 set to 1; conversion to 9 bits would lose information

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in SaiP4BMv2PacketInHeader headers[0]: target_egress_port: invalid format: hex string '0xf00' has bit #10 set to 1; conversion to 9 bits would lose information

================================================================================
Proto packet test: PSAMP packet header (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0046"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x1283"
    length: "0x0046"
    checksum: "0x0000"
  }
}
headers {
  ipfix_header {
    version: "0x000a"
    length: "0x003e"
    export_time: "0x64c18c23"
    sequence_number: "0x00000001"
    observation_domain_id: "0x00000001"
  }
}
headers {
  psamp_header {
    template_id: "0x0000"
    length: "0x002e"
    observation_time: "0x1775873b16a19e00"
    flowset: "0x04d2"
    next_hop_index: "0x0000"
    epoch: "0xabcd"
    ingress_port: "0x000d"
    egress_port: "0x000f"
    user_meta_field: "0x0000"
    dlb_id: "0x00"
    variable_length: "0xff"
    packet_sampled_length: "0x0012"
  }
}
payload: "AAAAAAAAAAAAAAAAAA"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PSAMP packet header (length of IPFIX & PSAMP is invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0046"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x1283"
    length: "0x0046"
    checksum: "0x0000"
  }
}
headers {
  ipfix_header {
    version: "0x000a"
    length: "0x0000"
    export_time: "0x64c18c23"
    sequence_number: "0x00000001"
    observation_domain_id: "0x00000001"
  }
}
headers {
  psamp_header {
    template_id: "0x0000"
    length: "0x0000"
    observation_time: "0x1775873b16a19e00"
    flowset: "0x04d2"
    next_hop_index: "0x0000"
    epoch: "0xabcd"
    ingress_port: "0x000d"
    egress_port: "0x000f"
    user_meta_field: "0x0000"
    dlb_id: "0x00"
    variable_length: "0xff"
    packet_sampled_length: "0x0001"
  }
}
payload: "AAAAAAAAAAAAAAAAAA"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in IpfixHeader headers[3]: length: Must be 0x003e, but was 0x0000 instead.
- in PsampHeader headers[4]: length: Must be 0x002e, but was 0x0000 instead.
- in PsampHeader headers[4]: packet_sampled_length: Must be 0x0012, but was 0x0001 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in IpfixHeader headers[3]: length: Must be 0x003e, but was 0x0000 instead.
- in PsampHeader headers[4]: length: Must be 0x002e, but was 0x0000 instead.
- in PsampHeader headers[4]: packet_sampled_length: Must be 0x0012, but was 0x0001 instead.

================================================================================
Proto packet test: PSAMP packet header (UDP checksum invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "ff:ee:dd:cc:bb:aa"
    ethernet_source: "55:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0046"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:c150:10::"
    ipv6_destination: "2002:a05:6860:749::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x1283"
    length: "0x0046"
    checksum: "0x0011"
  }
}
headers {
  ipfix_header {
    version: "0x000a"
    length: "0x003e"
    export_time: "0x64c18c23"
    sequence_number: "0x00000001"
    observation_domain_id: "0x00000001"
  }
}
headers {
  psamp_header {
    template_id: "0x0000"
    length: "0x002e"
    observation_time: "0x1775873b16a19e00"
    flowset: "0x04d2"
    next_hop_index: "0x0000"
    epoch: "0xabcd"
    ingress_port: "0x000d"
    egress_port: "0x000f"
    user_meta_field: "0x0000"
    dlb_id: "0x00"
    variable_length: "0xff"
    packet_sampled_length: "0x0012"
  }
}
payload: "AAAAAAAAAAAAAAAAAA"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[2]: checksum: Must be 0x28a1, but was 0x0011 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[2]: checksum: Must be 0x28a1, but was 0x0011 instead.

================================================================================
Proto packet test: PTP packet with UDP port 319 (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PTP packet with UDP port 320 (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x0140"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PTP in L2 packet (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x88f7"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PTP in L2 packet without payload (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x88f7"
  }
}
payload: "12345678901234567890123456789012345678901234"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in EthernetHeader headers[0]: expected at least 46 bytes of Ethernet payload, but got only 44
- headers[1]: header missing - expected PtpHeader

PadPacketToMinimumSize(packet) = true
new payload: "12345678901234567890123456789012345678901234\000\000"

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- headers[1]: header missing - expected PtpHeader

================================================================================
Proto packet test: PTP in L2 packet incorrect L3 header (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x88f7"
  }
}
headers {
  arp_header {
    hardware_type: "0x0001"
    protocol_type: "0x0800"
    hardware_length: "0x06"
    protocol_length: "0x04"
    operation: "0x0001"
    sender_hardware_address: "00:11:22:33:44:55"
    sender_protocol_address: "10.0.0.1"
    target_hardware_address: "00:00:00:00:00:00"
    target_protocol_address: "10.0.0.2"
  }
}
payload: "12345678901234567890123456789012345678"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in ArpHeader headers[1]: expected PtpHeader (because the previous header demands it), got ArpHeader

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in ArpHeader headers[1]: expected PtpHeader (because the previous header demands it), got ArpHeader

================================================================================
Proto packet test: PTP in L2 packet message_length incorrect (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x88f7"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "123456789012"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[1]: message_length: Must be 0x002e, but was 0x0036 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[1]: message_length: Must be 0x002e, but was 0x0036 instead.

================================================================================
Proto packet test: PTP packet does not set message_length (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[2]: checksum: Couldn't compute expected checksum: INVALID_ARGUMENT: while trying to serialize packet.headers(3): missing '0x'-prefix in hexadecimal string: ''
- in PtpHeader headers[3]: message_length: missing

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PTP packet reserved fields are non-zero (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x1"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x0a"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000002"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[3]: reserved0: Must be 0x0, but was 0x1 instead.
- in PtpHeader headers[3]: reserved1: Must be 0x00, but was 0x0a instead.
- in PtpHeader headers[3]: reserved2: Must be 0x00000000, but was 0x00000002 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[3]: reserved0: Must be 0x0, but was 0x1 instead.
- in PtpHeader headers[3]: reserved1: Must be 0x00, but was 0x0a instead.
- in PtpHeader headers[3]: reserved2: Must be 0x00000000, but was 0x00000002 instead.

================================================================================
Proto packet test: PTP packet message_length is wrong (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x0"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0000"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[3]: message_length: Must be 0x0036, but was 0x0000 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[3]: message_length: Must be 0x0036, but was 0x0000 instead.

================================================================================
Proto packet test: PTP packet message_type uses reserved value (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x003e"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x013f"
    length: "0x003e"
    checksum: "0x0000"
  }
}
headers {
  ptp_header {
    transport_specific: "0x0"
    message_type: "0x4"
    reserved0: "0x0"
    version_ptp: "0x0"
    message_length: "0x0036"
    domain_number: "0x00"
    reserved1: "0x00"
    flags: "0x0000"
    correction_field: "0x0000000000000000"
    reserved2: "0x00000000"
    source_port_identity: "0x00000000000000000000"
    sequence_id: "0x0000"
    control_field: "0x00"
    log_message_interval: "0x00"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[3]: message_type: value '0x4' is invalid. expecting a value in the range [0x0,0x3]

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PtpHeader headers[3]: message_type: value '0x4' is invalid. expecting a value in the range [0x0,0x3]

================================================================================
Proto packet test: PSP packet with UDP port 1000 (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0034"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e8"
    length: "0x0034"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001c"
    checksum: "0xfe85"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PSP packet with empty computed fields (valid except for computed fields)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e8"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in Ipv6Header headers[1]: payload_length: missing
- in UdpHeader headers[2]: length: missing
- in UdpHeader headers[2]: checksum: missing
- in UdpHeader headers[4]: length: missing
- in UdpHeader headers[4]: checksum: missing

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = true
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0034"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e8"
    length: "0x0034"
    checksum: "0xa0de"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x02"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001c"
    checksum: "0x0000"
  }
}
payload: "ABCDABCDABCDABCDABCD"

ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PSP packet with encrypted payload (valid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x002c"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e8"
    length: "0x002c"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x04"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x00"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x1"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = OK

Serialize(Packet) = OK

================================================================================
Proto packet test: PSP packet with UDP payload but not crypt_offset (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x0034"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e8"
    length: "0x0034"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x00"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
headers {
  udp_header {
    source_port: "0xbeef"
    destination_port: "0xabcd"
    length: "0x001c"
    checksum: "0xfe85"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[4]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in UdpHeader headers[4]: expected no header (because the previous header demands either no header or an unsupported header), got UdpHeader

================================================================================
Proto packet test: PSP packet with UDP port 1001 (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x002c"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e9"
    length: "0x002c"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x0"
    crypt_offset: "0x00"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x1"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PspHeader headers[3]: expected no header (because the previous header demands either no header or an unsupported header), got PspHeader

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PspHeader headers[3]: expected no header (because the previous header demands either no header or an unsupported header), got PspHeader

================================================================================
Proto packet test: PSP packet with wrong reserved values (invalid)
================================================================================
-- INPUT -----------------------------------------------------------------------
packet =
headers {
  ethernet_header {
    ethernet_destination: "00:ee:dd:cc:bb:aa"
    ethernet_source: "00:44:33:22:11:00"
    ethertype: "0x86dd"
  }
}
headers {
  ipv6_header {
    version: "0x6"
    dscp: "0x00"
    ecn: "0x0"
    flow_label: "0x12345"
    payload_length: "0x002c"
    next_header: "0x11"
    hop_limit: "0x42"
    ipv6_source: "2607:f8b0:11::"
    ipv6_destination: "2607:f8b0:12::"
  }
}
headers {
  udp_header {
    source_port: "0x08ae"
    destination_port: "0x03e8"
    length: "0x002c"
    checksum: "0x0000"
  }
}
headers {
  psp_header {
    next_header: "0x11"
    header_ext_length: "0x00"
    reserved0: "0x1"
    crypt_offset: "0x00"
    sample_bit: "0x0"
    drop_bit: "0x0"
    version: "0x1"
    virtualization_cookie_present: "0x0"
    reserved1: "0x0"
    security_parameters_index: "0x00000000"
    initialization_vector: "0x0000000000000000"
  }
}
payload: "ABCDABCDABCDABCDABCD"

-- OUTPUT ----------------------------------------------------------------------
ValidatePacket(packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PspHeader headers[3]: reserved0: Must be 0x0, but was 0x1 instead.
- in PspHeader headers[3]: reserved1: Must be 0x1, but was 0x0 instead.

PadPacketToMinimumSize(packet) = false

UpdateMissingComputedFields(packet) = false

Serialize(Packet) = INVALID_ARGUMENT: Packet invalid for the following reasons:
- in PspHeader headers[3]: reserved0: Must be 0x0, but was 0x1 instead.
- in PspHeader headers[3]: reserved1: Must be 0x1, but was 0x0 instead.
